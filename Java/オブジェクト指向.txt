・オブジェクト指向（主流）
→物　（を中心に考えた考え方）　
　　↑対比↓
・手続き型のプログラミング
（処理が中心）

例）オブジェクト指向
まずオブジェクトを作る
１、自分
２、店A
３、店B
４、店員
登場人物をピックアップしていく
オブジェクト同士のやり取りでプログラミングが進んでいく
オブジェクト同士のやり取りしている矢印を「メッセージ」と呼ぶ。

例）外食　（手続き型）

１、家を出る
２、店Aに行く
（もし店Aが休みだったら店Bに行く）→注文する→食べる・・・・
or
(店Aで注文する）→食べる・・・


・オブジェクトをプログラミングする。

例）スマートフォン

属性（性質）
・色、大きさ、形、OSetc be動詞

操作（機能）
・電話をかける、写真を撮る、メール送受信etc　一般動詞

プログラミングの書き方
構成
・クラス（Javaのファイル）
・フィールド（属性）
メンバ変数＊クラスの中全体で使うことができる。他のクラスからも場合によっては可
<書き方＞
例)public int a =10;

↑クラスを構成する二大要素それぞれメンバという。＊どっちかだけでもひとつのクラスは作成可能。↓


・メソッド（操作）
mainメソッドの中で書いた変数はメソッドの中でしか使えない。
ローカル変数＝メソッド内でかかれた変数。
<書き方>
戻り値の型(コンストラクタには記載不要）　メソッド名（引数）{
処理
return 戻り値;
}
例）人　引数１，５を与える、足してと指令→　電卓　６がフィードバックされるこの６が戻り値　戻り値の型は今回は数字なのでint型

taro.run 
taro→run taroさん走って。ただ走ればいいから
メソッドによって戻り値を必要しないメソッドも存在。その際return戻り値は不要
戻り値の型はその場合、戻り値を必要ありませにょということでvoidを置く


インスタンス化（クラスのコピー）
・原本を用意する。
例)Person{*変数の定義、データ型、原本クラスを作ると同時にその名前の型が使えるようになる} taro = new Person｛*Personクラスだから｝();

例）
Personクラス(原本）　あくまで型でしかない
↓　↓　↓
taro jiro hanako　それぞれインスタンスという　動いていくのはこっち

＊Javaの世界ではクラスは１つのファイル
　 Object指向ではインスタンスと比較して原本だよということでクラスと呼ばれ　 ることもある。

司令塔クラス（ファイルという意味）
１、インスタンス化の処理を実行する（コピーしてくれる）　登場人物を生み出す
２、インスタンスに対して命令し、処理を実行させる　　　　脚本をつくっていく
＊mainメソッドをもっている（mainメソッドはクラスが実行されたときに一番最初に自動実行される、それ以外もメソッドを作れるが他のクラスで呼び出されたりしないと実行されない。）


public class test {

	public static void main(String[] args) {
		Person taro = new Person();
		taro.(*〜のという意味）name="山田太郎";　*原本に　　　　　　　　　　　　　　　　　　　name,ageフィールドがあるから代入できる
		taro.age=20;
		System.out.println(taro.name);
		System.out.println(taro.age);

	}

}

<オブジェクト>
狭い意味　インスタンスのみ
広い意味　クラス　インスタンス　の場合がある

＜コンストラクタ＞
原本に書く。
クラスと同じ名前のメソッド
役割：クラスがインスタンス化されるときに最初に必ず実行される
いくつでも書くことができる、引数のパターンが異なっていないといけない。
フィールドとメソッドの間に書く

public Person(){}＊コンストラクタを記入しなかった場合これが自動生成され、実行される。他のコンストラクタを書く場合はこれは自動生成されないので手動で入力する必要あり。

＊コンストラクタは戻り値はないし、型も必要ないvoidも不要

this.name、そのクラスのインスタンスの中のという意味

オーバーロード
１つのクラスの中で同じ名前のメソッドを複数作ること
必ず引数の内容が異ならなくてはならない

<カプセル化>
セキュリティ上やる
○　○　○　○←ひとつひとつクラス　＊１つのグループにまとめることをグルーピング　グループのことをjavaではパッケージと呼ぶ（クラスをまとめたグループ）＊クラスの機能ごとにわけることがおおい
○　○　○　○

■■←クラスはこのような形のデフォルトパッケージというものにはいってる
■■　これがパッケージ。すべてのクラスはパッケージにはいっている

アクセス修飾子
・private　自分のクラスの中しか見えない
・protected
・public　すべてのプログラムがみえる　露出狂

みせる範囲のことを「スコープ」という。

//ほかのクラスに対してどこまでアクセスできるかを制限する
だから、エラーがでたのこアクセスができないから。

＜どうやって見えるようにするのか？＞
ゲッター　セッターメソッド

public class Person {

		private String name=null;
		private int age=0;
		
public String getName(){　見えるようにするためのメソッド
	　！！nameフィールドを他のクラスから読むためのメソッド！！		return this.name;←↑のprivate string name=null;のこと
		}
public void setName(String name){　書き込めるようにするためのメソッド
！！nameフィールドに他のクラスから書きこむためのメソッド		this.name=name;引数でcapsuleクラスから引き出して代入
		}
		}

<継承>
　　　　　　　　子クラス(サブクラス)  親クラス(スーパークラス*元になってる)
public class SmartPhone extends Mp3Player{
　　差分
}

継承したいクラスをextendsの後に書く
記入漏れがなくなる。
簡単。

オーバーライド
親クラスを子クラスが上書きできる。
書きこむだけ


<実装>
*作成時　インターフェイスを選択するとコードの入力が省ける
public interface Mp3Player{
         ↑抽象メソッドしか持たない
public abstract void play();

}

public SmartPhone extends Phone　複数追加不可　処理内容が記述してある、メソッドが被った場合、コンピューターが迷う implements Mp3Player 複数追加可能{
}
implements　の後に波かっこで閉じてるのにコンパイルエラーにならない理由。extendsしてるから
                           実装したら元となるインターフェースで定義されたメソッド
　　　　　　　　　　　　を子クラス側で必ずオーバーライド（上書き）し、さらに具体
　　　　　　　　　　　　的な処理内容を書かなければならない。
	
具体的な処理内容が決まっていない。機能はきまっているが。そういうときに使う














